<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>CHOLOG Dashboard</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #4361ee;
            --secondary-color: #3a0ca3;
            --success-color: #4CAF50;
            --warning-color: #ff9914;
            --danger-color: #ef476f;
            --info-color: #4cc9f0;
            --light-color: #f8f9fa;
            --dark-color: #212529;
            --gray-color: #6c757d;
            --border-color: #dee2e6;
        }

        body { 
            font-family: 'Noto Sans KR', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            margin: 20px; 
            font-size: 14px; 
            line-height: 1.5;
            color: var(--dark-color);
            background-color: #f5f7f9;
        }
        
        h1 {
            color: var(--secondary-color);
            margin-bottom: 20px;
            font-weight: 700;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 10px;
        }
        
        table { width: 100%; border-collapse: collapse; table-layout: fixed; margin-top: 10px; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 10px rgba(0,0,0,0.05); }
        th, td { border: 1px solid var(--border-color); padding: 12px; text-align: left; word-wrap: break-word; }
        th { background-color: var(--primary-color); color: white; font-weight: 600; }
        tr:nth-child(even) { background-color: #f2f5f9; }
        tr:hover { background-color: #e9f0fd; }
        
        .level-INFO { color: var(--info-color); font-weight: 500; }
        .level-WARN { color: var(--warning-color); font-weight: bold; }
        .level-ERROR { color: var(--danger-color); font-weight: bold; }
        .level-DEBUG { color: var(--gray-color); }
        .level-TRACE { color: #aaa; }
        
        .error-details { color: var(--danger-color); font-size: 0.9em; margin-top: 5px; }
        .mdc-details { color: var(--gray-color); font-size: 0.9em; margin-top: 5px; white-space: pre-wrap; }
        
        #logs-container { max-height: 75vh; overflow-y: auto; border-radius: 8px; border: 1px solid var(--border-color); margin-top: 15px; box-shadow: 0 2px 10px rgba(0,0,0,0.05); }

        /* 로그 행 클릭 가능 스타일 */
        #logs-table tbody tr {
            cursor: pointer;
            transition: all 0.2s;
        }
        #logs-table tbody tr:hover {
            background-color: #e2edff;
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
        }

        /* 필터 컨트롤 스타일 */
        .filters-container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        .filter-group {
            display: inline-block;
            margin-right: 15px;
            margin-bottom: 10px;
            vertical-align: top;
        }
        .filter-label {
            font-weight: 500;
            display: block;
            margin-bottom: 8px;
            color: var(--secondary-color);
        }
        select, input {
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            min-width: 140px;
            transition: all 0.3s;
            font-family: 'Noto Sans KR', sans-serif;
        }
        select:focus, input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.2);
        }
        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 8px 16px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 14px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.3s;
            font-family: 'Noto Sans KR', sans-serif;
            font-weight: 500;
        }
        button:hover {
            background-color: var(--secondary-color);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        button.reset {
            background-color: var(--danger-color);
        }
        button.reset:hover {
            background-color: #d64161;
        }
        .status-bar {
            margin-top: 10px;
            font-style: italic;
            color: var(--gray-color);
        }

        /* 모달 스타일 */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            backdrop-filter: blur(3px);
        }
        .modal-content {
            background-color: #fff;
            margin: 2% auto;
            padding: 25px;
            border: 1px solid #888;
            width: 90%;
            max-width: 1200px;
            max-height: 90vh;
            overflow-y: auto;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        .close-modal {
            color: var(--gray-color);
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s;
        }
        .close-modal:hover {
            color: var(--dark-color);
        }
        .detail-section {
            margin-bottom: 20px;
            padding: 18px;
            background-color: #f9f9f9;
            border-radius: 8px;
            border-left: 4px solid var(--primary-color);
            transition: all 0.3s;
        }
        .detail-section:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
        }
        .detail-section h3 {
            margin-top: 0;
            color: var(--secondary-color);
            font-weight: 600;
        }
        .json-view {
            font-family: 'Consolas', 'Monaco', monospace;
            white-space: pre-wrap;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #ddd;
            max-height: 400px;
            overflow-y: auto;
            font-size: 13px;
            line-height: 1.5;
        }
        .tab-container {
            margin-top: 20px;
        }
        .tab {
            overflow: hidden;
            border: 1px solid var(--border-color);
            background-color: #f5f7f9;
            border-radius: 8px 8px 0 0;
        }
        .tab button {
            background-color: transparent;
            float: left;
            border: none;
            outline: none;
            cursor: pointer;
            padding: 12px 20px;
            transition: 0.3s;
            font-size: 14px;
            color: var(--dark-color);
            border-radius: 0;
            margin: 0;
            font-weight: 500;
        }
        .tab button:hover {
            background-color: rgba(67, 97, 238, 0.1);
            transform: none;
            box-shadow: none;
        }
        .tab button.active {
            background-color: var(--primary-color);
            color: white;
        }
        .tabcontent {
            display: none;
            padding: 20px;
            border: 1px solid var(--border-color);
            border-top: none;
            border-radius: 0 0 8px 8px;
            animation: fadeIn 0.5s;
            background-color: white;
        }
        .tabcontent.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* 차트 컨테이너 */
        .chart-container {
            position: relative;
            height: 300px;
            width: 100%;
            margin-bottom: 30px;
            background-color: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
            transition: all 0.3s;
        }
        
        .chart-container:hover {
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            transform: translateY(-3px);
        }
        
        /* 통계 요약 정보 */
        .stats-summary {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stats-card {
            background-color: #fff;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
            padding: 20px;
            flex: 1 1 200px;
            max-width: calc(33% - 20px);
            border-top: 4px solid var(--primary-color);
            transition: all 0.3s;
        }
        
        .stats-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }
        
        .stats-card h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 16px;
            color: var(--secondary-color);
            font-weight: 600;
        }
        
        .stats-card .value {
            font-size: 28px;
            font-weight: 700;
            color: var(--dark-color);
        }
        
        /* 통계 보기 버튼 */
        #showStats {
            position: fixed;
            bottom: 30px;
            right: 30px;
            padding: 12px 20px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            z-index: 100;
            font-weight: 600;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        #showStats .stats-icon {
            font-size: 18px;
        }
        
        #showStats:hover {
            background-color: var(--secondary-color);
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.25);
        }

        /* 통계 모달 스타일 - 크기 줄임 */
        .stats-modal-content {
            max-width: 1000px;
            width: 80%;
            margin: 3% auto;
            padding: 25px;
            background-color: #f5f7f9;
        }
    </style>
</head>
<body>
<h1>CHOLOG Dashboard</h1>

<!-- 필터 컨트롤 -->
<div class="filters-container">
    <div class="filter-group">
        <label class="filter-label" for="apiKey-filter">API 키</label>
        <select id="apiKey-filter">
            <option value="">전체</option>
            <!-- 자바스크립트로 동적 추가 -->
        </select>
    </div>

    <div class="filter-group">
        <label class="filter-label" for="service-filter">서비스</label>
        <select id="service-filter">
            <option value="">전체</option>
            <!-- 자바스크립트로 동적 추가 -->
        </select>
    </div>

    <div class="filter-group">
        <label class="filter-label" for="level-filter">로그 레벨</label>
        <select id="level-filter">
            <option value="">전체</option>
            <!-- 자바스크립트로 동적 추가 -->
        </select>
    </div>

    <div class="filter-group">
        <label class="filter-label" for="status-filter">HTTP 상태 코드</label>
        <select id="status-filter">
            <option value="">전체</option>
            <!-- 자바스크립트로 동적 추가 -->
        </select>
    </div>

    <div class="filter-group">
        <label class="filter-label" for="path-filter">경로 (URL)</label>
        <input type="text" id="path-filter" placeholder="경로 검색...">
    </div>

    <div class="filter-group">
        <label class="filter-label" for="query-filter">메시지 검색</label>
        <input type="text" id="query-filter" placeholder="키워드 검색...">
    </div>

    <div class="filter-group">
        <label class="filter-label" for="timeRange-filter">시간 범위</label>
        <select id="timeRange-filter">
            <option value="1h">최근 1시간</option>
            <option value="6h">최근 6시간</option>
            <option value="24h" selected>최근 24시간</option>
            <option value="7d">최근 7일</option>
            <option value="30d">최근 30일</option>
        </select>
    </div>

    <div class="filter-group" style="margin-top: 20px;">
        <button id="apply-filters">필터 적용</button>
        <button id="reset-filters" class="reset">필터 초기화</button>
    </div>

    <div class="status-bar">
        <span id="log-count">0</span>개의 로그가 표시됨
    </div>
</div>

<div id="logs-container">
    <table id="logs-table">
        <thead>
        <tr>
            <th style="width: 15%;">Timestamp(KST)</th>
            <th style="width: 7%;">Level</th>
            <th style="width: 15%;">Logger</th>
            <th style="width: 10%;">Service</th>
            <th style="width: 10%;">Request ID</th>
            <th style="width: 43%;">Message & Details</th>
        </tr>
        </thead>
        <tbody><!-- 로그 데이터가 여기에 동적으로 추가됩니다. --></tbody>
    </table>
</div>

<!-- 로그 상세 모달 -->
<div id="logDetailModal" class="modal">
    <div class="modal-content">
        <span class="close-modal">&times;</span>
        <h2>로그 상세 정보</h2>

        <div class="tab">
            <button class="tablinks active" onclick="openTab(event, 'formattedView')">형식화된 보기</button>
            <button class="tablinks" onclick="openTab(event, 'allFieldsView')">원본 JSON</button>
        </div>

        <div id="formattedView" class="tabcontent active">
            <div class="detail-section">
                <h3>기본 정보</h3>
                <div id="basicInfo"></div>
            </div>

            <div class="detail-section">
                <h3>요청 정보</h3>
                <div id="requestInfo"></div>
            </div>

            <div class="detail-section">
                <h3>성능 지표</h3>
                <div id="performanceInfo"></div>
            </div>

            <div class="detail-section">
                <h3>MDC 컨텍스트</h3>
                <div id="mdcInfo"></div>
            </div>

            <div class="detail-section">
                <h3>헤더 정보</h3>
                <div id="headersInfo"></div>
            </div>

            <div class="detail-section">
                <h3>오류 정보</h3>
                <div id="errorInfo"></div>
            </div>
        </div>

        <div id="allFieldsView" class="tabcontent">
            <pre id="allFields" class="json-view"></pre>
        </div>
    </div>
</div>

<!-- 통계 차트 모달 -->
<div id="statsModal" class="modal">
    <div class="modal-content stats-modal-content">
        <span class="close-modal" id="closeStatsModal">&times;</span>
        <h2>로그 통계 시각화</h2>
        
        <!-- 통계 요약 정보 -->
        <div class="stats-summary">
            <div class="stats-card">
                <h3>총 로그 수</h3>
                <div class="value" id="totalLogs">0</div>
            </div>
            <div class="stats-card">
                <h3>에러 로그 수</h3>
                <div class="value" id="errorLogs">0</div>
            </div>
            <div class="stats-card">
                <h3>평균 응답 시간</h3>
                <div class="value" id="avgResponseTime">0ms</div>
            </div>
        </div>
        
        <div class="tab">
            <button class="tablinks active" onclick="openStatsTab(event, 'hourlyChart')">시간별 분포</button>
            <button class="tablinks" onclick="openStatsTab(event, 'levelChart')">로그 레벨 분포</button>
            <button class="tablinks" onclick="openStatsTab(event, 'statusChart')">상태 코드 분포</button>
        </div>
        
        <div id="hourlyChart" class="tabcontent active">
            <h3>시간별 로그 발생 건수 (KST)</h3>
            <div class="chart-container">
                <canvas id="hourlyDistributionChart"></canvas>
            </div>
        </div>
        
        <div id="levelChart" class="tabcontent">
            <h3>로그 레벨 분포</h3>
            <div class="chart-container">
                <canvas id="levelDistributionChart"></canvas>
            </div>
        </div>
        
        <div id="statusChart" class="tabcontent">
            <h3>HTTP 상태 코드 분포</h3>
            <div class="chart-container">
                <canvas id="statusDistributionChart"></canvas>
            </div>
        </div>
    </div>
</div>

<button id="showStats">
    <span class="stats-icon">📊</span> 통계 보기
</button>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-gradient"></script>
<script>
    // 현재 로그 데이터를 저장할 변수
    let currentLogs = [];
    // 차트 객체 저장
    let hourlyChart = null;
    let levelChart = null;
    let statusChart = null;

    // 필터 상태를 저장할 객체
    const filters = {
        apiKey: '',
        path: '',
        level: '',
        status: '',
        service: '',
        query: '',
        timeRange: '24h'
    };

    // 차트 테마 색상
    const chartColors = {
        primary: '#4361ee',
        secondary: '#3a0ca3',
        success: '#4CAF50',
        warning: '#ff9914',
        danger: '#ef476f',
        info: '#4cc9f0',
        background: '#f5f7f9',
        text: '#212529',
        grid: 'rgba(0, 0, 0, 0.05)',
        hourly: {
            line: '#4361ee',
            fill: 'rgba(67, 97, 238, 0.2)'
        },
        levels: {
            ERROR: '#ef476f',
            WARN: '#ff9914',
            INFO: '#4cc9f0',
            DEBUG: '#6c757d'
        },
        status: {
            '5xx': '#ef476f',
            '4xx': '#ff9914',
            '3xx': '#ffbf69',
            '2xx': '#4CAF50'
        }
    };

    // UTC 시간을 한국 시간(KST)으로 변환하는 함수
    function convertToKST(utcTimeStr) {
        if (!utcTimeStr) return 'N/A';
        try {
            // UTC 시간을 Date 객체로 변환
            const date = new Date(utcTimeStr);
            
            // 한국 시간으로 포맷팅 (UTC+9)
            return date.toLocaleString('ko-KR', {
                timeZone: 'Asia/Seoul',
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });
        } catch (e) {
            console.error('Date conversion error:', e);
            return utcTimeStr; // 변환 실패 시 원본 반환
        }
    }

    // UTC 시간에서 한국 시간의 시간(0-23)을 추출하는 함수
    function getKSTHour(utcTimeStr) {
        if (!utcTimeStr) return 0;
        try {
            const date = new Date(utcTimeStr);
            // UTC 시간에 9시간 추가하여 KST로 변환
            const kstHour = (date.getUTCHours() + 9) % 24;
            return kstHour;
        } catch (e) {
            console.error('Hour extraction error:', e);
            return 0;
        }
    }

    // 모달 관련 요소
    const modal = document.getElementById("logDetailModal");
    const statsModal = document.getElementById("statsModal");
    const closeModalBtn = document.querySelector(".close-modal");
    const closeStatsModalBtn = document.getElementById("closeStatsModal");
    const showStatsBtn = document.getElementById("showStats");

    // 통계 모달 열기 버튼
    showStatsBtn.onclick = function() {
        loadChartData();
        statsModal.style.display = "block";
    }

    // 통계 모달 닫기 버튼
    closeStatsModalBtn.onclick = function() {
        statsModal.style.display = "none";
    }

    // 닫기 버튼 이벤트
    closeModalBtn.onclick = function() {
        modal.style.display = "none";
    }

    // 모달 외부 클릭 시 닫기
    window.onclick = function(event) {
        if (event.target == modal) {
            modal.style.display = "none";
        }
        if (event.target == statsModal) {
            statsModal.style.display = "none";
        }
    }

    // 차트 데이터 로드 함수
    async function loadChartData() {
        try {
            let url = '/stats/charts';
            const params = new URLSearchParams();
            
            if (filters.apiKey) params.append('apiKey', filters.apiKey);
            if (filters.service) params.append('serviceName', filters.service);
            params.append('period', filters.timeRange || '24h');
            
            const queryString = params.toString();
            if (queryString) {
                url += '?' + queryString;
            }
            
            const response = await fetch(url);
            if (!response.ok) {
                console.error('Failed to fetch chart data:', response.statusText);
                return;
            }
            
            const chartData = await response.json();
            
            // 통계 요약 정보 로드
            loadStatsSummary();
            
            // 차트 업데이트
            updateHourlyChart(chartData.hourlyDistributionChart);
            updateLevelChart(chartData.levelDistributionChart);
            updateStatusChart(chartData.statusDistributionChart);
            
        } catch (error) {
            console.error('Error loading chart data:', error);
        }
    }
    
    // 통계 요약 정보 로드
    async function loadStatsSummary() {
        try {
            let url = '/stats';
            const params = new URLSearchParams();
            
            if (filters.apiKey) params.append('apiKey', filters.apiKey);
            if (filters.service) params.append('serviceName', filters.service);
            params.append('timeRange', filters.timeRange || '24h');
            
            const queryString = params.toString();
            if (queryString) {
                url += '?' + queryString;
            }
            
            const response = await fetch(url);
            if (!response.ok) {
                console.error('Failed to fetch stats summary:', response.statusText);
                return;
            }
            
            const statsData = await response.json();
            
            // 요약 정보 업데이트
            document.getElementById('totalLogs').textContent = statsData.totalLogs || 0;
            
            // 에러 로그 수 계산
            const levelDist = statsData.levelDistribution || {};
            document.getElementById('errorLogs').textContent = levelDist.ERROR || 0;
            
            // 평균 응답 시간
            const responseTimeMetrics = statsData.responseTimeMetrics || {};
            const avgTime = responseTimeMetrics.average || 0;
            document.getElementById('avgResponseTime').textContent = 
                avgTime.toFixed(2) + 'ms';
            
        } catch (error) {
            console.error('Error loading stats summary:', error);
        }
    }
    
    // 시간별 차트 업데이트
    function updateHourlyChart(data) {
        // 한국 시간 레이블 (0-23시)
        const labels = Array.from({length: 24}, (_, i) => `${i}시`);
        
        // 데이터 매핑
        const counts = Array(24).fill(0);
        if (data) {
            data.forEach(item => {
                // UTC 시간을 KST로 변환 (서버에서 시간을 변환하지 않으므로 여기서 처리)
                const kstHour = (item.hour + 9) % 24;
                counts[kstHour] = item.count;
            });
        }
        
        // 차트 생성 또는 업데이트
        const ctx = document.getElementById('hourlyDistributionChart').getContext('2d');
        
        // 이전 차트 삭제
        if (hourlyChart) {
            hourlyChart.destroy();
        }
        
        // 선형 그라데이션 생성
        const gradient = ctx.createLinearGradient(0, 0, 0, 300);
        gradient.addColorStop(0, 'rgba(67, 97, 238, 0.7)');
        gradient.addColorStop(1, 'rgba(67, 97, 238, 0.05)');
        
        // 새 차트 생성 - 바 차트에서 선 그래프로 변경
        hourlyChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    label: '로그 수',
                    data: counts,
                    borderColor: chartColors.hourly.line,
                    backgroundColor: gradient,
                    pointBackgroundColor: 'white',
                    pointBorderColor: chartColors.primary,
                    pointBorderWidth: 2,
                    pointRadius: 4,
                    pointHoverRadius: 6,
                    fill: true,
                    tension: 0.3,
                    borderWidth: 3
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: chartColors.grid,
                            drawBorder: false
                        },
                        ticks: {
                            font: {
                                weight: 'bold'
                            },
                            padding: 10,
                            precision: 0,  // 정수만 표시하도록 설정
                            stepSize: 1    // 눈금 간격을 1로 설정
                        },
                        title: {
                            display: true,
                            text: '로그 건수',
                            font: {
                                weight: 'bold',
                                size: 14
                            },
                            padding: {top: 10, bottom: 10}
                        }
                    },
                    x: {
                        grid: {
                            display: false,
                            drawBorder: false
                        },
                        ticks: {
                            font: {
                                weight: 'bold'
                            },
                            padding: 10
                        },
                        title: {
                            display: true,
                            text: '시간 (KST)',
                            font: {
                                weight: 'bold',
                                size: 14
                            },
                            padding: {top: 10, bottom: 10}
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    },
                    title: {
                        display: true,
                        text: '시간별 로그 분포 (KST)',
                        font: {
                            size: 16,
                            weight: 'bold'
                        },
                        padding: {top: 10, bottom: 20}
                    },
                    tooltip: {
                        backgroundColor: 'rgba(0, 0, 0, 0.8)',
                        titleFont: {
                            weight: 'bold'
                        },
                        bodyFont: {
                            size: 14
                        },
                        displayColors: false,
                        callbacks: {
                            label: function(context) {
                                return `${context.raw}건의 로그`;
                            },
                            labelTextColor: function() {
                                return '#fff';
                            }
                        },
                        padding: 12,
                        cornerRadius: 8
                    }
                },
                interaction: {
                    intersect: false,
                    mode: 'index'
                },
                animation: {
                    duration: 1500,
                    easing: 'easeOutQuart'
                },
                elements: {
                    line: {
                        borderJoinStyle: 'round'
                    }
                }
            }
        });
    }
    
    // 로그 레벨 차트 업데이트
    function updateLevelChart(data) {
        if (!data || data.length === 0) return;
        
        const labels = data.map(item => item.level);
        const counts = data.map(item => item.count);
        
        // 로그 레벨에 따른 색상 지정
        const backgroundColors = labels.map(level => {
            return chartColors.levels[level] || '#6c757d';
        });
        
        const ctx = document.getElementById('levelDistributionChart').getContext('2d');
        
        // 이전 차트 삭제
        if (levelChart) {
            levelChart.destroy();
        }
        
        // 새 차트 생성 - 파이 차트에서 바 차트로 변경
        levelChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [{
                    data: counts,
                    backgroundColor: backgroundColors,
                    borderWidth: 0,
                    borderRadius: 8,
                    maxBarThickness: 60,
                    hoverOffset: 10
                }]
            },
            options: {
                indexAxis: 'y', // 수평 바 차트
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        beginAtZero: true,
                        grid: {
                            color: chartColors.grid,
                            drawBorder: false
                        },
                        ticks: {
                            precision: 0, // 정수만 표시
                            font: {
                                weight: 'bold'
                            },
                            padding: 10
                        }
                    },
                    y: {
                        grid: {
                            display: false,
                            drawBorder: false
                        },
                        ticks: {
                            font: {
                                weight: 'bold',
                                size: 13
                            }
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    },
                    title: {
                        display: true,
                        text: '로그 레벨 분포',
                        font: {
                            size: 16,
                            weight: 'bold'
                        },
                        padding: {top: 10, bottom: 20}
                    },
                    tooltip: {
                        backgroundColor: 'rgba(0, 0, 0, 0.8)',
                        titleFont: {
                            weight: 'bold'
                        },
                        bodyFont: {
                            size: 14
                        },
                        callbacks: {
                            label: function(context) {
                                const percent = Math.round(
                                    (context.raw / counts.reduce((a, b) => a + b, 0)) * 100
                                );
                                return [`${context.raw}건 (${percent}%)`, `전체 로그 중 ${percent}%`];
                            }
                        },
                        displayColors: false,
                        padding: 12,
                        cornerRadius: 8
                    }
                },
                animation: {
                    duration: 1200,
                    easing: 'easeOutQuart'
                }
            }
        });
    }
    
    // 상태 코드 차트 업데이트
    function updateStatusChart(data) {
        if (!data || data.length === 0) return;
        
        const labels = data.map(item => item.status.toString());
        const counts = data.map(item => item.count);
        
        // 상태 코드에 따른 색상 지정
        const backgroundColors = labels.map(status => {
            const statusCode = parseInt(status);
            if (statusCode >= 500) return chartColors.status['5xx'];
            if (statusCode >= 400) return chartColors.status['4xx'];
            if (statusCode >= 300) return chartColors.status['3xx'];
            if (statusCode >= 200) return chartColors.status['2xx'];
            return '#6c757d';
        });
        
        const ctx = document.getElementById('statusDistributionChart').getContext('2d');
        
        // 이전 차트 삭제
        if (statusChart) {
            statusChart.destroy();
        }
        
        // 새 차트 생성 - 수평 바 차트 유지
        statusChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [{
                    data: counts,
                    backgroundColor: backgroundColors,
                    borderWidth: 0,
                    borderRadius: 8,
                    maxBarThickness: 60,
                    hoverOffset: 10
                }]
            },
            options: {
                indexAxis: 'y', // 수평 바 차트
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        beginAtZero: true,
                        grid: {
                            color: chartColors.grid,
                            drawBorder: false
                        },
                        ticks: {
                            precision: 0, // 정수만 표시
                            font: {
                                weight: 'bold'
                            },
                            padding: 10
                        }
                    },
                    y: {
                        grid: {
                            display: false,
                            drawBorder: false
                        },
                        ticks: {
                            font: {
                                weight: 'bold',
                                size: 13
                            }
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    },
                    title: {
                        display: true,
                        text: 'HTTP 상태 코드 분포',
                        font: {
                            size: 16,
                            weight: 'bold'
                        },
                        padding: {top: 10, bottom: 20}
                    },
                    tooltip: {
                        backgroundColor: 'rgba(0, 0, 0, 0.8)',
                        titleFont: {
                            weight: 'bold'
                        },
                        bodyFont: {
                            size: 14
                        },
                        callbacks: {
                            label: function(context) {
                                const statusCode = parseInt(context.label);
                                let statusText = '';
                                if (statusCode >= 500) statusText = '서버 오류';
                                else if (statusCode >= 400) statusText = '클라이언트 오류';
                                else if (statusCode >= 300) statusText = '리다이렉션';
                                else if (statusCode >= 200) statusText = '성공';
                                else statusText = '정보';
                                
                                const percent = Math.round(
                                    (context.raw / counts.reduce((a, b) => a + b, 0)) * 100
                                );
                                
                                return [
                                    `상태 코드: ${context.label} (${statusText})`, 
                                    `${context.raw}건 (${percent}%)`
                                ];
                            }
                        },
                        displayColors: false,
                        padding: 12,
                        cornerRadius: 8
                    }
                },
                animation: {
                    duration: 1200,
                    easing: 'easeOutQuart'
                }
            }
        });
    }
    
    // 통계 탭 전환 함수
    function openStatsTab(evt, tabName) {
        const tabcontent = document.querySelectorAll("#statsModal .tabcontent");
        tabcontent.forEach(tab => tab.classList.remove("active"));
        
        const tablinks = document.querySelectorAll("#statsModal .tablinks");
        tablinks.forEach(link => link.classList.remove("active"));
        
        document.getElementById(tabName).classList.add("active");
        evt.currentTarget.classList.add("active");
    }

    // 탭 전환 함수
    function openTab(evt, tabName) {
        const tabcontent = document.getElementsByClassName("tabcontent");
        for (let i = 0; i < tabcontent.length; i++) {
            tabcontent[i].classList.remove("active");
        }

        const tablinks = document.getElementsByClassName("tablinks");
        for (let i = 0; i < tablinks.length; i++) {
            tablinks[i].classList.remove("active");
        }

        document.getElementById(tabName).classList.add("active");
        evt.currentTarget.classList.add("active");
    }

    // 필터 옵션 로드 함수
    async function loadFilterOptions() {
        try {
            const response = await fetch('/filters');
            if (!response.ok) {
                console.error('Failed to fetch filter options:', response.statusText);
                return;
            }

            const filterOptions = await response.json();

            // 각 필터 드롭다운 채우기
            populateFilterDropdown('apiKey-filter', filterOptions.apiKeys || []);
            populateFilterDropdown('service-filter', filterOptions.services || []);
            populateFilterDropdown('level-filter', filterOptions.levels || []);
            populateFilterDropdown('status-filter', filterOptions.statusCodes || []);

        } catch (error) {
            console.error('Error loading filter options:', error);
        }
    }

    // 드롭다운 채우기 함수
    function populateFilterDropdown(elementId, options) {
        const dropdown = document.getElementById(elementId);
        const currentValue = dropdown.value; // 현재 선택 값 저장

        // 첫 번째 옵션 ("전체") 유지, 나머지 제거
        while (dropdown.options.length > 1) {
            dropdown.remove(1);
        }

        // 새 옵션 추가
        options.forEach(option => {
            if (option) { // null이나 빈 값 제외
                const optionElement = document.createElement('option');
                optionElement.value = option;
                optionElement.textContent = option;
                dropdown.appendChild(optionElement);
            }
        });

        // 이전에 선택한 값 복원 (가능한 경우)
        if (currentValue && [...dropdown.options].some(o => o.value === currentValue)) {
            dropdown.value = currentValue;
        }
    }

    // 로그 상세 정보 보기 함수
    async function showLogDetail(index) {
        try {
            // API를 통해 상세 정보 가져오기
            const response = await fetch(`/logs/detail/${index}`);
            if (!response.ok) {
                console.error('Failed to fetch log details:', response.statusText);
                return;
            }
            
            const detailLog = await response.json();
            if (!detailLog) return;

            // 기본 정보
            let basicInfoHtml = `
                <p><strong>타임스탬프:</strong> ${convertToKST(detailLog.timestamp)}</p>
                <p><strong>로그 레벨:</strong> <span class="level-${detailLog.level}">${detailLog.level}</span></p>
                <p><strong>메시지:</strong> ${escapeHtml(detailLog.message)}</p>
                <p><strong>로거:</strong> ${detailLog.logger}</p>
                <p><strong>스레드:</strong> ${detailLog.thread}</p>
                <p><strong>서비스:</strong> ${detailLog.serviceName}</p>
                <p><strong>환경:</strong> ${detailLog.environment}</p>
                <p><strong>API 키:</strong> ${detailLog.apiKey}</p>
            `;
            document.getElementById('basicInfo').innerHTML = basicInfoHtml;

            // 요청 정보
            let requestInfoHtml = `<p>요청 정보가 없습니다.</p>`;
            if (detailLog.requestMethod || detailLog.requestUri) {
                requestInfoHtml = `
                <p><strong>요청 ID:</strong> ${detailLog.requestId || '-'}</p>
                <p><strong>HTTP 메소드:</strong> ${detailLog.requestMethod || '-'}</p>
                <p><strong>URI:</strong> ${detailLog.requestUri || '-'}</p>
                <p><strong>클라이언트 IP:</strong> ${detailLog.clientIp || '-'}</p>
                <p><strong>User-Agent:</strong> ${detailLog.userAgent || '-'}</p>
                <p><strong>HTTP 상태:</strong> ${detailLog.httpStatus || '-'}</p>
                <p><strong>모바일:</strong> ${detailLog.uaMobile !== undefined ? (detailLog.uaMobile ? '예' : '아니오') : '-'}</p>
                <p><strong>플랫폼:</strong> ${detailLog.uaPlatform || '-'}</p>
            `;
            }
            document.getElementById('requestInfo').innerHTML = requestInfoHtml;

            // 성능 지표
            let performanceInfoHtml = `<p>성능 지표가 없습니다.</p>`;
            if (detailLog.performanceMetrics && Object.keys(detailLog.performanceMetrics).length > 0) {
                performanceInfoHtml = Object.entries(detailLog.performanceMetrics)
                    .map(([key, value]) => `<p><strong>${key}:</strong> ${value}</p>`)
                    .join('');
            }
            document.getElementById('performanceInfo').innerHTML = performanceInfoHtml;

            // MDC 컨텍스트
            let mdcInfoHtml = `<p>MDC 컨텍스트가 없습니다.</p>`;
            if (detailLog.mdcContext && Object.keys(detailLog.mdcContext).length > 0) {
                mdcInfoHtml = Object.entries(detailLog.mdcContext)
                    .map(([key, value]) => `<p><strong>${key}:</strong> ${escapeHtml(String(value))}</p>`)
                    .join('');
            }
            document.getElementById('mdcInfo').innerHTML = mdcInfoHtml;

            // 헤더 정보
            let headersInfoHtml = `<p>헤더 정보가 없습니다.</p>`;
            if (detailLog.headers && Object.keys(detailLog.headers).length > 0) {
                headersInfoHtml = `<h4>요청 헤더</h4>`;
                headersInfoHtml += Object.entries(detailLog.headers)
                    .map(([key, value]) => `<p><strong>${key}:</strong> ${escapeHtml(String(value))}</p>`)
                    .join('');
            }
            if (detailLog.responseHeaders && Object.keys(detailLog.responseHeaders).length > 0) {
                headersInfoHtml += `<h4>응답 헤더</h4>`;
                headersInfoHtml += Object.entries(detailLog.responseHeaders)
                    .map(([key, value]) => `<p><strong>${key}:</strong> ${escapeHtml(String(value))}</p>`)
                    .join('');
            }
            document.getElementById('headersInfo').innerHTML = headersInfoHtml;

            // 오류 정보
            let errorInfoHtml = `<p>오류 정보가 없습니다.</p>`;
            if (detailLog.throwable && Object.keys(detailLog.throwable).length > 0) {
                errorInfoHtml = `
                <p><strong>예외 클래스:</strong> ${detailLog.throwable.className || '-'}</p>
                <p><strong>에러 메시지:</strong> ${detailLog.throwable.message || '-'}</p>
            `;

                if (detailLog.throwable.stackTrace && detailLog.throwable.stackTrace.length > 0) {
                    errorInfoHtml += `<p><strong>스택 트레이스:</strong></p><pre>${detailLog.throwable.stackTrace.join('\n')}</pre>`;
                }

                if (detailLog.throwable.cause) {
                    errorInfoHtml += `
                    <p><strong>원인 예외:</strong> ${detailLog.throwable.cause.className || '-'}</p>
                    <p><strong>원인 메시지:</strong> ${detailLog.throwable.cause.message || '-'}</p>
                `;
                }
            }
            document.getElementById('errorInfo').innerHTML = errorInfoHtml;

            // 가공된 필드 뷰
            const allFieldsObj = {...detailLog};
            if (allFieldsObj.rawJson) delete allFieldsObj.rawJson; // rawJson 필드 제거
            document.getElementById('allFields').textContent = JSON.stringify(allFieldsObj, null, 2);

            // 모달 표시
            modal.style.display = "block";

        } catch (error) {
            console.error('Error showing log details:', error);
        }
    }

    // 로그 로드 함수
    async function loadLogs() {
        try {
            // 필터 적용하여 URL 구성
            let url = '/logs';
            const params = new URLSearchParams();

            if (filters.apiKey) params.append('apiKey', filters.apiKey);
            if (filters.path) params.append('path', filters.path);
            if (filters.level) params.append('level', filters.level);
            // 여러 파라미터 이름 지원
            if (filters.status) {
                params.append('status', filters.status);
                params.append('httpStatus', filters.status);
                params.append('statusStr', filters.status);
            }
            if (filters.service) {
                params.append('service', filters.service);
                params.append('serviceName', filters.service);
            }
            if (filters.query) params.append('query', filters.query);
            if (filters.timeRange) params.append('timeRange', filters.timeRange);

            const queryString = params.toString();
            if (queryString) {
                url += '?' + queryString;
            }

            const response = await fetch(url);
            if (!response.ok) {
                console.error('Failed to fetch logs:', response.statusText);
                return;
            }

            const logs = await response.json();
            // 현재 로그 데이터 저장
            currentLogs = logs;

            const tbody = document.querySelector('#logs-table tbody');

            // 테이블 초기화
            tbody.innerHTML = '';

            // 로그 카운트 업데이트
            document.getElementById('log-count').textContent = logs.length;

            if (!logs || logs.length === 0) {
                // 로그가 없을 때 메시지 표시
                const row = document.createElement('tr');
                row.innerHTML = `<td colspan="6" style="text-align: center; color: #888;">No logs yet...</td>`;
                tbody.appendChild(row);
                return;
            }

            // 로그 데이터 표시 (이미 컨트롤러에서 최신 순으로 정렬됨)
            logs.forEach((log, index) => {
                const row = document.createElement('tr');
                row.setAttribute('data-index', index);
                row.addEventListener('click', () => showLogDetail(index));

                // 주요 필드 표시
                const timestamp = log.timestamp ? convertToKST(log.timestamp) : 'N/A';
                const level = log.level || 'UNKNOWN';
                const logger = log.logger ? log.logger.split('.').pop() : 'N/A';
                const service = log.serviceName || 'N/A';
                const requestId = log.requestId || '-';

                // 메시지 및 상세 정보 구성
                let messageDetailsHtml = `<div class="message">${escapeHtml(log.message || '')}</div>`;

                // HTTP 요청 정보 추가 (있는 경우)
                if (log.requestMethod && log.requestUri) {
                    messageDetailsHtml += `<div class="http-info" style="font-size:0.9em; color: #0066cc;">${log.requestMethod} ${log.requestUri}`
                    if (log.httpStatus) {
                        messageDetailsHtml += ` -> ${log.httpStatus}`;
                    }
                    if(log.performanceMetrics && log.performanceMetrics.responseTime >= 0) {
                        messageDetailsHtml += ` (${log.performanceMetrics.responseTime}ms)`;
                    }
                    messageDetailsHtml += `</div>`;
                }

                // 예외 정보 추가 (있는 경우)
                if (log.throwable) {
                    messageDetailsHtml += `<div class="error-details"><strong>Error:</strong> ${escapeHtml(log.throwable.className || '')}: ${escapeHtml(log.throwable.message || '')}</div>`;
                }

                // MDC 정보 추가 (있는 경우)
                if (log.mdcContext) {
                    const mdcEntries = Object.entries(log.mdcContext)
                        .filter(([key]) => key !== 'requestId' && key !== 'requestMethod')
                        .map(([key, value]) => `  ${key}: ${escapeHtml(String(value))}`)
                        .join('\n');

                    if (mdcEntries.length > 0) {
                        messageDetailsHtml += `<div class="mdc-details"><strong>MDC:</strong>\n${mdcEntries}</div>`;
                    }
                }

                // API 키 정보 추가 (서비스 식별)
                if (log.apiKey) {
                    messageDetailsHtml += `<div style="font-size:0.8em; color: #666; margin-top: 5px;">API Key: ${log.apiKey}</div>`;
                }

                row.innerHTML = `
                        <td>${timestamp}</td>
                        <td><span class="level-${level}">${level}</span></td>
                        <td>${logger}</td>
                        <td>${service}</td>
                        <td>${requestId}</td>
                        <td>${messageDetailsHtml}</td>
                    `;

                tbody.appendChild(row);
            });

        } catch (error) {
            console.error('Error loading or processing logs:', error);
        }
    }

    // HTML 이스케이프 함수
    function escapeHtml(unsafe) {
        if (!unsafe) return '';
        return unsafe
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    }

    // 필터 적용 이벤트 리스너
    document.getElementById('apply-filters').addEventListener('click', () => {
        // 모든 필터 값 수집
        filters.apiKey = document.getElementById('apiKey-filter').value;
        filters.service = document.getElementById('service-filter').value;
        filters.level = document.getElementById('level-filter').value;
        filters.status = document.getElementById('status-filter').value;
        filters.path = document.getElementById('path-filter').value;
        filters.query = document.getElementById('query-filter').value;
        filters.timeRange = document.getElementById('timeRange-filter').value;

        // 로그 새로고침
        loadLogs();
    });

    // 필터 초기화 이벤트 리스너
    document.getElementById('reset-filters').addEventListener('click', () => {
        // 모든 필터 초기화
        document.getElementById('apiKey-filter').value = '';
        document.getElementById('service-filter').value = '';
        document.getElementById('level-filter').value = '';
        document.getElementById('status-filter').value = '';
        document.getElementById('path-filter').value = '';
        document.getElementById('query-filter').value = '';
        document.getElementById('timeRange-filter').value = '24h';

        // 필터 객체도 초기화
        Object.keys(filters).forEach(key => filters[key] = '');

        // 로그 새로고침
        loadLogs();
    });

    // 엔터 키로 필터 적용
    document.getElementById('path-filter').addEventListener('keyup', (e) => {
        if (e.key === 'Enter') document.getElementById('apply-filters').click();
    });

    document.getElementById('query-filter').addEventListener('keyup', (e) => {
        if (e.key === 'Enter') document.getElementById('apply-filters').click();
    });

    // 초기 로드 및 주기적 업데이트
    window.addEventListener('load', () => {
        loadFilterOptions();
        loadLogs();

        // 주기적 업데이트
        setInterval(() => {
            loadLogs();
            // 필터 옵션도 주기적으로 업데이트 (하지만 로그보다 덜 자주)
            if (Math.random() < 0.2) { // 약 20% 확률로 필터 옵션 업데이트
                loadFilterOptions();
            }
        }, 3000);
    });
</script>
</body>
</html>